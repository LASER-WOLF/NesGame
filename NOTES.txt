///////////////////////////////////////////////////////////////////////////////
// This document contains course notes for the course:
// "NES Programming with 6502 Assembly" by Gustavo Pezzi
// https://pikuma.com/courses/nes-game-programming-tutorial
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// NINTENDO ENTERTAINMENT SYSTEM (NES) SPECIFICATIONS:
///////////////////////////////////////////////////////////////////////////////
 - CPU (NTSC)      : Ricoh 2A03 8-bit processor (6502 core) @ 1.79MHz
 - CPU (PAL)       : Ricoh 2A07 8-bit processor (6502 core) @ 1.66MHz
 - Internal memory : 2KB WRAM + 2KB VRAM + 256 Bytes SPR-RAM
 - Graphics        : Ricoh 2C02 PPU (256x240 pixels)


###############################################################################
#                            Ricoh 2A03 CPU (6502)                            #
###############################################################################

                               6502 CPU PINOUT
                               ----------------
                     GND-----<|1             40|>-----RES(INV)
                     RDY-----<|2             39|>-----φ2(OUT)
                 φ1(OUT)-----<|3             38|>-----SO
                IRQ(INV)-----<|4             37|>-----φ0(IN)
                      NC-----<|5             36|>-----NC
                NMI(INV)-----<|6      R      35|>-----NC
                    SYNC-----<|7      I      34|>-----R/W(INV)
                     VCC-----<|8      C      33|>-----D0
                      A0-----<|9      O      32|>-----D1
                      A1-----<|10     H      31|>-----D2
                      A2-----<|11            30|>-----D3
                      A3-----<|12     2      29|>-----D4
                      A4-----<|13     A      28|>-----D5
                      A5-----<|14     0      27|>-----D6
                      A6-----<|15     3      26|>-----D7
                      A7-----<|16            25|>-----A15
                      A8-----<|17            24|>-----A14
                      A9-----<|18            23|>-----A13
                     A10-----<|19            22|>-----A12
                     A11-----<|20            21|>-----VSS
                               ----------------


                              6502 CPU REGISTERS
############################## [8-BIT DATA BUS] ###############################
|    |            |       |            |                                      |
|    |            |       |            |                                      |
|  -------------------------------------------------------------------------  |
|    |            |       |            |                                      |
|  [Y(8)]-------[X(8)]  [A(8)]         |                                      |
|  (INDEXED REGISTERS)  (ACCUMULATOR)  |                                      |
I    |                   |  |  |       |                                      M
N    |                   |  |  |       |                                      E
/  [SP(8)]               |  |   \     /                                       M
O  (STACK POINTER)       |  |     \ /                                         O
U    |                   |  |    [ALU]--------------------[P]                 R
T    |                   |  |    (ARITHMETIC-LOGIC UNIT)  (PROCESSOR FLAGS)   Y
|  [PC(16)]              |  |______|                       N V - B D I Z C    |
|  (PROGRAM COUNTER)     |                                                    |
|    |                   |                                                    |
|  -------------------------------------------------------------------------  |
|    |                   |                                                    |
|    |                   |                                                    |
########################### [16-BIT ADDRESS BUS] ##############################


///////////////////////////////////////////////////////////////////////////////
// 6502 PROCESSOR STATUS FLAGS REGISTER:
///////////////////////////////////////////////////////////////////////////////

 7 6 5 4 3 2 1 0  <--- Bit
 N V - B D I Z C  <--- Flag
 | |   | | | | |
 | |   | | | | |
 | |   | | | | |___ Carry Flag             0 = False            1 = True
 | |   | | | |
 | |   | | | |____ Zero flag               0 = Result not zero  1 = Result zero
 | |   | | |
 | |   | | |_____ IRQ Disabled flag        0 = Enable           1 = Disable
 | |   | |
 | |   | |______ Decimal mode (BCD) flag   0 = False            1 = True
 | |   |                        |  
 | |   |_______ Break flag      |          0 = No break         1 = Break
 | |                            |
 | |_________ Overflow flag     |          0 = False            1 = True
 |                              |
 |__________ Negative flag      |          0 = Positive         1 = Negative
                                |
                               NOTE: The BCD flag is disabled on the NES CPU

// Carry flag:
   [0] 1 1 1 1 1 1 1 1  =  [FF]
 + [0] 0 0 0 0 0 0 0 1  =  [01]
  ---------------------
 = [1] 0 0 0 0 0 0 0 0  =  [00]
     \
       \ __ CARRY FLAG

// Negative numbers using two's complement:
 -128's  64's  32's  16's   8's   4's   2's   1's
    |     |     |     |     |     |     |     |
    |     |     |     |     |     |     |     |
    -     -     -     -     -     -     -     -
    0     1     1     1     1     1     1     1  =  [7F]  =  127 
    -     -     -     -     -     -     -     -
    1     0     0     0     0     0     0     0  =  [80]  =  -128
    -     -     -     -     -     -     -     -
    1     1     1     1     1     1     1     1  =  [FF]  =  -1
    -     -     -     -     -     -     -     -

// Overflow flag (overflow to negative):
   0 1 1 1 1 1 1 1  =  [7F]  =  127
 + 0 0 0 0 0 0 0 1  =  [01]  =  1
  -----------------
 = 1 0 0 0 0 0 0 0  =  [80]  =  -128
    \
      \ __ SIGN BIT


///////////////////////////////////////////////////////////////////////////////
// CPU MEMORY MAP:
///////////////////////////////////////////////////////////////////////////////

 $0000           $2000           $4020                                   $FFFF
 |               |               |                                       |
 #      RAM      #   PPU & APU   #              CARTRIDGE SPACE          #
  ----------------------------------------------------------------------- 
 | Z |     |     |           |   |               |                   |   | 
 | E |  S  |     |           |   |               |                   | V |
 | R |  Y  |     |           |   |               |                   | E |
 | O |  S  |     |     P     | A |    PRG-RAM    |                   | C |
 |   |  T  |     |     P     | P |    BAT SAVE   |      PRG-ROM      | T |
 | P |  E  |     |     U     | U |    MAPPER     |                   | O |
 | A |  M  |     |           |   |               |                   | R |
 | G |     |     |           |   |               |                   | S |
 | E |     |     |           |   |               |                   |   |
  -----------------------------------------------------------------------
     #     #                 #                   #                   #
     |     |                 |                   |                   |
     $00FF $0800             $4000               $8000               $FFFA

 - Memory mapped I/O
 - 16-bit address space (2 to the power of 16 = 65.536 = 64KB)
 - Discrete Logic Chip figures out the location of the address (RAM/PPU/etc.)
   when you are sending instructions to the CPU.
 - System RAM: $0000 - $0800 (2KB internal RAM)
     - Page zero (fast!): $0000 - $00FF
     - Some parts of the 2KB of internal RAM at $0000 - $07FF have
       predefined purposes by the 6502 architecture.
     - The stack always uses some part of the $0100 - $01FF page.


///////////////////////////////////////////////////////////////////////////////
// 6502 ASSEMBLER:
///////////////////////////////////////////////////////////////////////////////

 - The ca65 assembler turns 6502 assembly code into machine code:
     LDA #2 -> [ASSEMBLER] -> (A9 02) 1010 1001 0000 0010
       \                          \       \
        Assembly code              Hex     * Machine code
   
   * Machine code is the raw binary values fed to the processor to perform a
     certain operation.
 
 - Examples of assembly to hex:
   LDA = Load decimal value to A (accumulator)
   STA = Store value from A to memory address
   LDX = Load the X register with value from memory
   DEX = Decrement X
   
   Assembly:     Hex:
   LDA #2     =  A9 02
   STA $2B    =  85 2B
   LDX $1234  =  AE 34 12
   DEX        =  CA    \
                        * 12 has swapped places with 34
   
   * NES has a Little Endian architecture

 - Installing the ca65 assembler and the FCEUX NES emulator on Arch Linux:
     $ yay -S cc65
     $ sudo pacman -S fceux

 - Assembling .nes file:
     $ ca65 <name>.asm -o <name>.o
     $ ld65 -C nes.cfg <name>.o -o <name>.nes

 - Running .nes file:
     $ fceux <name>.nes

 - Assembling, running and cleaning (deleting assembled files) can be done
   with a Makefile.

 - ca65 Users Guide: https://cc65.github.io/doc/ca65.html
 
 - ca65 is very powerful and supports:
    - macros (.macro / .endmacro)
    - enums (.enum / .endenum)
    - structs (.struct / .endstruct)
    - .sizeof()
    - and more..

///////////////////////////////////////////////////////////////////////////////
// 6502 ASSEMBLY CODE:
///////////////////////////////////////////////////////////////////////////////

 - Roll-off: When decrementing $00 -> $FF
 - Roll-off: When incrementing $FF -> $00
 - Macros are copy/pasted code by the assembler (.macro / .endmacro)
 - Subroutines are jumps that happen at runtime (.proc / .endproc)
   Code inside a subroutine is in a seperate scope from the rest of the code.
 - Labels are memory addresses that can be referenced by name (:LabelName)
 - Unnamed labels can be created with : and referenced with :- (previous) or :+ (next)
 - Pointers are a 16-bit address stored as lo-byte, followed by hi-byte.
   And are referenced by using parentheses.
   Ptr: .res 2 ; Reserving 2 bytes (16 bits) for the pointer Ptr during variable declaration
   lda #<Adr   ; Loading the lo-byte of the address Adr into A
   sta Ptr     ; Storing the lo-byte to the pointer Ptr
   lda #>Adr   ; Loading the hi-byte of the address Adr into A
   sta Ptr+1   ; Storing the hi-byte to the pointer Ptr
   (Ptr)       ; Referencing the pointer Ptr
   (Ptr),y     ; Referencing the pointer Ptr with a offset Y (only the register Y can be used to offset a pointer)
 - Two bytes can be combined to create a decimal number with the hi-byte
   representing the integer part and the lo-byte the fractional part of the number.
   16-bit number using 8.8 fixed-point math: hi-byte . lo-byte
                                      Integer part /          \ Fractional part
 - 8-bit -> 16-bit sign extension:
   To sign extend any number from 8 bits to 16 bits, we look at the sign-bit 
   of the original number and we copy it to all the new bits of the high-byte 
   of the new 16-bit number. If the original sign-bit was 0, we fill all the 
   left new bits with 0. If the original sign-bit was 1, we fill all the 
   new left bits with 1.

///////////////////////////////////////////////////////////////////////////////
// 6502 INSTRUCTIONS (OPCODES):
///////////////////////////////////////////////////////////////////////////////

 - List of 6502 instructions:      
     http://www.6502.org/tutorials/6502opcodes.html

 - List of 6502 instructions (alt link):
     http://www.6502.org/users/obelisk/6502/instructions.html

 - Load and store instructions:
     LDA  ; load the A register
     LDX  ; load the X register
     LDY  ; load the Y register

     STA  ; store the A register
     STX  ; store the X register
     STY  ; store the Y register
 
     ; Loading / storing modes:

     ; Immediate mode:               
     ; LDA #80    Loads the A register with the literal decimal value 80
     
     ; Absolute (zero-page) mode:    
     ; LDA $80    Loads the A register with the value inside memore address $80
     
     ; Immediate mode:               
     ; LDA #$80   Loads the A register with the literal hexadecimal number $80
     
     ; Absolute (zero-page) indexed: 
     ; STA $80,X  Store the value of A into memory address ($80 + X)

     ; Loading sets Zero flag if the loaded number is zero
     ; and Negative flag if the loaded number is negative (the leftmost bit is set)

- Arithmetic instructions (addition, subtract):
     ADC  ; add to the accumulator (with carry)
     SBC  ; subtract from the accumulator (with carry)

     CLC  ; clear the carry flag (usually performed before addition)
     SEC  ; sets the carry flag (usually performed before subtraction)
 
 - Increment and Decrement instructions:
     INC  ; increment memory by one
     INX  ; increment X by one
     INY  ; increment Y by one
 
     DEC  ; decrement memory by one
     DEX  ; decrement X by one
     DEY  ; decrement Y by one

     ; Flag Z=1 if the result is zero, 0 otherwise
     ; Flag N=1 if bit 7(sign bit) is 1, 0 otherwise
     ; Note: The accumulator has no increment instruction. Use CLC and ADC #1 instead.

 - Logical Instructions:
     AND  ; logical AND
     EOR  ; exclusive OR
     ORA  ; logical inclusive OR
     BIT  ; bit test

     ; AND: The result of a logical AND is only true if both inputs are true.
     ;      A bitwise AND can be used to mask certain bits of a byte.
     ; EOR: An Exclusive-OR is similar to logical OR, with the exception that
     ;     it is false when both inputs are true.
     ; ORA: The result of a logical OR (ORA) is true if at least
     ;      one of the inputs are true.

     ; AND can be used to mask bits
     ; Example:
     ; STA #%00001111
     ; AND #%01010101
     ; The result is 00000101

     ; AND can also be used to check for even/odd numbers, and to check
     ; if a number is divisible by 2/4/8/16/32/64
     ; Examples:
     ; AND #%00000001 - Can be used to mask all but the rightmost bit, if the
     ; result is true it means the original number is an
     ; even number and divisible by two.
     ; AND #%00000011 - Can be used to mask all but the two rightmost bits, if the
     ; result is true it means the original number is divisible by four.
     ; AND #%00000111 - If the result is true the original number is 
     ; divisible by eight
     ; AND #%00001111 - Divisible by 16
     ; et cetera...

     ; EOR can be used to flip bits
     ; Example:
     ; STA #%00000110
     ; EOR #%00000011
     ; The result is 00000101

     ; ORA can be used to set a particular bit to true
     ; Example:
     ; STA #%00011100
     ; ORA #%00000111
     ; The result is 00011111

     ; ORA + EOR can be used to set a partical bit to false
     ; Example:
     ; STA #%11101011
     ; ORA #%00111100
     ; EOR #%00111100
     ; The result is 11000011

 - Jump, Branch, Compare Instructions:
     JMP  ; jump to another location     GOTO

     BCC  ; branch on carry clear        C == 0
     BCS  ; branch on carry set          C == 1
     BEQ  ; branch on equal to zero      Z == 1
     BNE  ; branch on not equal to zero  Z == 0
     BMI  ; branch on minus              N == 1
     BPL  ; branch on plus               N == 0
     BVC  ; branch on overflow clear     V == 0
     BVS  ; branch on overflow set       V == 1
     
     CMP  ; compare accumulator
     CPX  ; compare X register
     CPY  ; compare Y register

     ; Relative vs. Absolute Jumps:
     ; JMP is an absolute jump and can jump to anywhere.
     ; Branching (BEQ, BMI, BCS, etc.) is a relative jump that uses a byte 
     ; to define the relative target position.
     ; It can maximum jump 127 lines up or down.
     ; To use branch instructions with absolute jump we'll nest a JMP
     ; instruction inside a branch.
     ; Example, here's the original code:
     ;   BNE JumpDestination
     ; To replace it with an absolute jump we'll change it to:
     ;   BEQ :+
     ;     JMP JumpDestination
     ;   :

     ; The CMP instruction is used to compare a value from memory with the one 
     ; in the accumulator. It sets the N(egative), Z(ero) and C(arry) flags
     ; depending on the result of the comparison:
     ; 
     ;   CMP Value:    N Z C
     ;   If A < Value  - 0 0
     ;   If A = Value  0 1 1
     ;   If A > Value  - 0 1

 - Shift and Rotate Instructions:
     ASL  ; arithmetic shift left
     LSR  ; logical shift right
     ROL  ; rotate left
     ROR  ; rotate right

     ; LSR: Logical Shift Right, moves all bits one step to the right.
     ;      Inserting a 0 in the leftmost bit and moving the rightmost bit
     ;      to the carry flag.
     ;      1 0 1 0 1 1 1 1 -> [1] 0 1 0 1 0 1 1 1
     ; ASL: Logical Shift Left, same as LSR but moving bits one step to the left.
     ;      Inserting a 0 in the rightmost bit and moving the leftmost bit
     ;      to the carry flag.
     ;      1 0 1 0 1 1 1 1 -> [1] 0 1 0 1 1 1 1 0
     ; ROR: Rotate Right, moves all the bits one step right.
     ;      The rightmost bit moves over to the leftmost side.
     ;      1 0 1 0 1 1 1 1 -> 1 1 0 1 0 1 1 1
     ; ROL: Rotate Left, moves all the bits one step left.
     ;      The leftmost bit moves over to the rightmost side.
     ;      1 0 1 0 1 1 1 1 -> 0 1 0 1 1 1 1 1

     ; Multiplication and division by 2,4,6,8,16 etc. can by done with bit shifting
     ; (ASL) Shifting left is equivalent to multiplying by 2.
     ; Example: (27) 00011011 * 2 = (54) 00110110
     ; (LSR) Shifting right is equivalent to dividing by 2.
     ; Example: (74) 01001010 / 2 = (37) 00100101

 - Transfer Instructions:
     TAX  ; transfer A to X
     TAY  ; transfer A to Y
     TXA  ; transfer X to A
     TYA  ; transfer Y to A

 - Stack Instructions:
     TSX  ; transfer stack pointer to X
     TXS  ; transfer X to stack pointer
     PHA  ; push accumulator on stack
     PHP  ; push processor status on stack
     PLA  ; pull accumulator from stack
     PLP  ; pull processor status from stack

 - Subroutine Instructions:
     JSR  ; jump to a subroutine
     RTS  ; return from a subroutine

 - Set/Reset Instructions:
     CLD  ; clear decimal mode flag
     CLI  ; clear interrupt disable flag
     CLV  ; clear overflow flag 
     SEI  ; set interrupt disable flag
     RTI  ; return from interrupt

     ; It is customary to add a CLD (clear decimal mode flag) instruction
     ; during initialization since the NES does not support the decimal flag.

 - NOP/BRK Instructions:
     BRK  ; force an interrupt
     NOP  ; no operation


###############################################################################
#                                NES GRAPHICS                                 #
###############################################################################

                                 [TV SCREEN]
                               256 x 240 PIXELS
                            (NTSC 60Hz / PAL 50Hz)
                     -----------------------------------   <-
                    |                                   |    | 
                    |           ,___          .-;'      |    |
                    |           `"-.`\_...._/`.`        |    |
                    |        ,      \        /          |    |
                    |     .-' ',    / ()   ()\          | H  |
                    |    `'._   \  /()    .  (|         | B  |
                    |        > .' ;,     -'-  /         | L  |
                    |       / <   |;,     __.;          | A  |-- 240 VISIBLE
                    |       '-.'-.|  , \    , \         | N  |    SCANLINES
                    |          `>.|;, \_)    \_)        | K  |
                    |           `-;     ,    /          |    |
                    |              \    /   <           |    |
                    |               '. <`'-,_)          |    |
                    |                '._)               |    |
                    |                                   |    |
                     -----------------------------------   <-
                    |                                   |    |
                    |               VBLANK              |    |-- 21 SCANLINES
                    |                                   |    |   OF  VERTICAL
                     ----------------------------------    <-       BLANK
                    |---------341 PPU CYCLES/PIXELS----------|
                    |----256 VISIBLE SCANLINE PIXELS----|



///////////////////////////////////////////////////////////////////////////////
 
 - Each NTSC frame has a total of 262 scanlines:
   240 visible scanlines + 21 scanlines of VBLANK + 1 scanline of pre-VBLANK
 - VRAM has to be updated during the period of VBLANK
 - The PPU triggers an NMI interrupt to the CPU every time a new VBLANK starts.
 - Updating VRAM (background) and OAM (sprites) has to be done during
   the period of VBLANK. So we'll do this when NMI is triggered.
 - HBLANK is the time it takes from the beam to go from right to left again
   after each scanline. The PPU handles this for us.
 - Each scanline lasts 341 PPU clock-cycles. This is the same as
   113.6 CPU clock cycles. 1 CPU cycle = 3 PPU cycles.

///////////////////////////////////////////////////////////////////////////////

                                COLOR PALETTE
                                -------------
                                (4)BACKGROUND                  
                                (4)SPRITES                     NAME TABLE 0
                                -------------                  + ATTRIBUTES
  PATTERN TABLE 0                     |                        NAME TABLE 1
  PATTERN TABLE 1                     |                        + ATTRIBUTES
        |                             |                             |
     CHR-ROM <--------------------> [PPU] <--------------------> 2KB VRAM
   (CARTRIDGE)             (PICTURE PROCESSING UNIT)            (VIDEO RAM)
                                      |
                                      |
                                PPU REGISTERS
                              -----------------
                              $2000:   PPU_CTRL
                              $2001:   PPU_MASK
                              $2002: PPU_STATUS
                              $2003:   OAM_ADDR
                              $2004:   OAM_DATA
                              $2005: PPU_SCROLL
                              $2006:   PPU_ADDR
                              $2007:   PPU_DATA
                              -----------------

///////////////////////////////////////////////////////////////////////////////

   $2000 : PPU_CTRL   :  7 6 5 4 3 2 1 0
                         | | | | | |  \ \ 
                         | | | | | |   Base name table address
                         | | | | | |   00: $2000  ;  01: $2400
                         | | | | | |   10: $2800  ;  11: $2C00
                         | | | | |  \
                         | | | | |   PPU_DATA increment size
                         | | | | |   0: add 1, going accross
                         | | | | |   1: add 32, going down
                         | | | |  \
                         | | | |   Sprite pattern table no. (0;1)
                         | | |  \
                         | | |   Background pattern table no. (0;1)
                         | |  \
                         | |   Sprite size
                         | |  0:8x8; 1:8x16
                         |  \
                         |   PPU master/slave select (0;1)
                          \
                           Generate NMI at the start of VBLANK? (0;1)

   $2001 : PPU_MASK   :  7 6 5 4 3 2 1 0
                         | | | | | | |  \ 
                         | | | | | | |   Grayscale
                         | | | | | |  \
                         | | | | | |   Show background in leftmost 8 pixels
                         | | | | |  \ 
                         | | | | |   Show sprites in leftmost 8 pixels
                         | | | |  \ 
                         | | | |   Show background
                         | | |  \ 
                         | | |   Show sprites
                         | |  \ 
                         | |   Emphasize red
                         |  \ 
                         |   Emphasize green
                          \ 
                           Emphasize blue

   $2002 : PPU_STATUS :  7 6 5 4 3 2 1 0
                         | | |  \ \ \ \ \
                         | | |   PPU open bus
                         | |  \
                         | |   Sprite overflow
                         | |   (more than 8 sprites in one scanline)
                         |  \
                         |   Sprite-0 Hit
                          \
                           In VBLANK (0:Not in VBLANK; 1:In VBLANK)

   $2003 : OAM_ADDR   : Define address of sprite OAM here (usually $00)
   $2004 : OAM_DATA   : Write OAM data here (usually not used directly)
   $2005 : PPU_SCROLL : Used to write the scroll position 
                        (Indicates which pixel of the nametable
                        is at the top-left corner)
   $2006 : PPU_ADDR   : Write the hi-byte & lo-byte of the PPU address
                        (LATCH REGISTER)
   $2007 : PPU_DATA   : Write the data to be sent to the address
                        defined at PPU_ADDR

 PPU_STATUS/PPU_ADDR/PPU_DATA:
 - PPU_ADDR is a latch register that takes a 8-bit hi-byte, followed by
   a 8-bit lo-byte and stores the combined values as a 16-bit memory address.
 - When PPU_STATUS is read (e.g. BIT PPU_STATUS) the PPU_ADDR latch is reset.
 - When storing a byte in PPU_DATA the PPU_ADDR is automatically incremented.
   According to PPU_CTRL bit 2, either increment by 1 or increment by 32.

//////////////////////////////////////////////////////////////////////////////
// PPU MEMORY MAP:
//////////////////////////////////////////////////////////////////////////////

           $0000 ------- #-----------------# --------
                         | PATTERN TABLE 0 | CHR-ROM
                         |                 | 4KB
           $1000 ------- #-----------------# --------
                         | PATTERN TABLE 1 | CHR-ROM
                         |                 | 4KB
           $2000 ------- #-----------------# --------
                         |  NAME TABLE 0   | 1KB
                         |  + ATTRIBUTES   | 
           $2400 ------- #-----------------# --------
                         |  NAME TABLE 1   | 1KB
                         |  + ATTRIBUTES   | 
           $2800 ------- #-----------------# --------
                         |  NAME TABLE 2   | 1KB
                         |  + ATTRIBUTES   | 
           $2C00 ------- #-----------------# --------
                         |  NAME TABLE 3   | 1KB
                         |  + ATTRIBUTES   | 
           $3000 ------- #-----------------# --------
                         |     MIRRORS     |
                         |   $2000-$2EFF   |
           $3F00 ------- #-----------------# --------
                         |   PALETTE BG    | 16 bytes
                         |-----------------| --------
                         | PALETTE SPRITES | 16 bytes
                         #-----------------#
              
///////////////////////////////////////////////////////////////////////////////
// PATTERN TABLES AND NAMETABLES:
///////////////////////////////////////////////////////////////////////////////

           [8x8  TILE]
            16  BYTES         [PATTERN TABLE]           [CHR-ROM]
         0 0 1 1 2 2 3 3        4096  BYTES             8192 BYTES   
         0 0 1 1 2 2 3 3      ---------------       ------------------
         0 0 1 1 2 2 3 3     |   256 TILES   |     | 2 PATTERN TABLES |
         0 0 1 1 2 2 3 3 --> | STORED IN ONE | --> |    STORED ON     |
         0 0 1 1 2 2 3 3     | PATTERN TABLE |     |    CARTRIDGE     |
         0 0 1 1 2 2 3 3      ---------------       ------------------
         0 0 1 1 2 2 3 3                                  | 
         0 0 1 1 2 2 3 3                                  |
          \                                               |
          COLOR INDEX (0-3)                               |
              2 BITS                                      |
                                                          |
                          [NAMETABLE]                     |
                           1024 BYTES                     |
                    -----------------------               |
                   |       960 BYTES:      |    REFERENCE |
                   | STORES 960 REFERENCES |  <-----------+
                   |   TO TILES SELECTED   |
                   |  FROM THE BACKGROUND  |          [VRAM]
                   |     PATTERN TABLE     |        2048 BYTES
                   |    FORMING A 32x30    |       ------------
                   |   GRID TO FILL THE    |      |  STORES 2  |
                   |     ENTIRE SCREEN     |      | NAMETABLES |
                    -----------------------   --> | CONTAINING |
                   |       64 BYTES:       |      | TILES AND  |
                   | STORES 64 REFERENCES  |      | COLOR DATA |
                   |   TO COLOR PALETTES   |       ------------
                   |   SELECTED FROM THE   |
                   |   BACKGROUND COLOR    |
                   |  PALETTE SET FORMING  |    REFERENCE
                   |  A 8x8 GRID TO COLOR  |  <-----------+
                   |   ALL THE TILES IN    |              |
                   |     GROUPS OF 4       |              |
                    -----------------------               |
                                                          |
                                                          |
         [SET OF COLOR PALETTES]                        [WRAM]
                16 BYTES                               32 BYTES
        [1 2 3 4] ----------> PALETTE #1       --------------------------
           [1 2 3 4] -------> PALETTE #2      | 2 SETS OF COLOR PALETTES |
              [1 2 3 4] ----> PALETTE #3  --> |  ONE SET FOR BACKGROUND  |
                 [1 2 3 4] -> PALETTE #4      |  AND ONE SET FOR SPRITES |
                   \                           -------------------------- 
                    1 BYTE REPRESENTING          
                       A SINGLE COLOR

 - A vanilla cartridge has two pattern tables (0: Sprites and 1: Background)
   but more pattern tables can be added if the cartridge has a mapper.
   A pattern table contains 256 tiles. A tile can be 8x8 or 8x16.
   Each pixel on a tile contains a value from 0-3, representing an index
   to reference a color from the selected color palette.
 - VRAM contains two nametables used to draw the background.
   Each nametable needs to store tiles (from the pattern tables)
   and color data. VRAM has 2048 bytes of storage capacity that 
   is divided into 1024 bytes assigned for each of the two nametables.
   Tiles are stored in the 32x30 tile grid and colors are stored
   in the 8x8 attribute grid. Each entry in both the tile grid and
   the attribute grid needs 1 byte of storage space.
   A nametable contains 960 tiles + 64 color attributes, totalling 1024 bytes.
 - The color palette contains two sets of 4 color palettes.
   One set for painting the background tiles and one set for painting 
   the sprites. Each set contain 4 palettes and each individual palette
   contains 4 colors represented as a value between 0-255.
   The first color in every indvidual palette is the background color.
 - The pattern tables can be thought of as different brushes 
   while the nametable is the canvas in which we paint the final result.
 - If we want to implement CHR Bank Switching we need to update the
   iNes header and the nes.cfg file to simulate a mapper.
   We can then use address $8000 to trigger bank switching.

///////////////////////////////////////////////////////////////////////////////

 - Nametable mirroring is used to enable scrolling backgrounds:

            VERTICAL MIRRORING:         HORIZONTAL MIRRORING:
            USED FOR GAMES THAT         USED FOR GAMES THAT
            SCROLL HORIZONTALLY         SCROLL VERTICALLY
                 --- ---                
                | A | B |                 ---    M    ---
                 --- ---                 | A | <-I-> | A |
                  |   |                   ---    R    ---
               M I R R O R               | B | <-R-> | B |
                  |   |                   ---    O    --- 
                 --- ---                         R        
                | A | B |
                 --- ---

                       HORIZONTAL SCROLLING:
                                              
       #------ NAMETABLE 0  -----#------ NAMETABLE 1  -----#                                       
        ------------------------- -------------------------  
       |             I           |           I             |
       |             I                       I             |
       |             I           |           I             |
       |             I                       I             |
       |             I -->       |           I -->         |
       |             I                       I             |
       |             I           |           I             |
       |             I                       I             |
       |             I           |           I             |
        ------------------------- -------------------------
                     #------ TV SCREEN ------#                         
 
///////////////////////////////////////////////////////////////////////////////

 - Dynamic loading of a scrolling background can be implemented by defining
   an XScroll variable that increments to scroll the background.
   XScroll indicates the current position of the viewport on the active
   nametable. When XScroll reaches the end it resets back to 0 and we
   switch active nametable from 1->0 or 0->1.
   As XScroll increments we dynamically load column by column of tiles into
   the nametable that is off-screen, so that there is always a column of
   background tiles ready to appear as we keep scrolling.
   Loading of tile columns into the inactive nametable happends every
   8 pixels (a tile is 8x8). And color attribute data for the off-screen
   nametable is loaded every 32 pixels (since a tile on the color attribute
   grid covers 4 tiles (8x4=32)).
  

                             Column data is dynamically loaded from
                               CHR-ROM to VRAM (nametable) every
                                 time XScroll is increased by 8
 BackgroundData:                           ---------->
 .byte $13,$13,$13,$13,$21, ... ----------------------------------+
 .byte $13,$13,$75,$14,$22, ... ----------------------------------|-+
 .byte $13,$13,$6e,$13,$20, ... ----------------------------------|-|-+
                                                                  | | | 
                                                      OFF-SCREEN  | | | 
                            [TV SCREEN]               NAMETABLE \ | | | 
                      32 COLUMNS ALREADY LOADED                   1 2 3 4 5...
  --------------------------------------------------------------- -----------
 I                                                               I | | | | | |
 I                                                               I | | | | | |
 I                                                               I | | | | | |
 I                                                               I | | | | | |
 I                                                               I | | | | | |
 I                                                               I | | | | | |
 I                                                               I | | | | | |
 I                          HORIZONTALLY                         I | | | | | |
 I                          SCROLLING                            I | | | | | |
 I                          BACKGROUND                           I | | | | | |
 I                                                               I | | | | | |
 I                           XScroll++                           I | | | | | |
 I                       --> --> --> -->                         I | | | | | |
 I                                                               I | | | | | |
 I                                                               I | | | | | |
 I                                                               I | | | | | |
 I                                                               I | | | | | |
 I                                                               I | | | | | |
 I                                                               I | | | | | |
 I                                                               I | | | | | |
  --------------------------------------------------------------- -----------
                       8 COLUMNS ALREADY LOADED                   1       2...
 AttributeData:                                                   |       |
 .byte $ff,$aa,$aa,$aa,$9a, ... ----------------------------------+       |
 .byte $ff,$aa,$aa,$aa,$5a, ... ------------------------------------------+
                                           ---------->
                           Color attribute data is dynamically loaded
                             from CHR-ROM to VRAM (nametable) every
                               time XScroll is increased by 32

///////////////////////////////////////////////////////////////////////////////

 - If we want to display a status bar at the top of the screen we can store
   the status bar tiles in a nametable and split the nametable into
   two parts. The top part being non-scrolling and containing the status bar,
   and the lower part of the nametable being used to store the scrolling
   game background. To declare the point of the split we can use bit 7
   "sprite-0-hit" of the PPU_STATUS. "sprite-0-hit" starts with the value 0
   each frame and becomes 1 after "sprite-0" (the very first sprite stored in
   the PPU OAM) has been rendered. So to declare which point on the
   screen we want to split the nametable we'll simply place the sprite-0
   at that point and toggle the background scrolling setting on or off
   according to the "sprite-0-hit" bit of the PPU_STATUS.

                                   [NAMETABLE]
                            ------------------------
     [STATUS  BAR]         |                        |
    (NON-SCROLLING) --------> SCORE: 200  TIME:055  |
                           |                        |
             SPRITE-0 ------>[S0]-------------------
            (PPU  OAM)     |                        |
                           |                        |
                           |                        |
         GAME BACKGROUND --->                       |
           (SCROLLING)     |                        |
                           |                        |
                           |                        |
                           |                        |
                            ------------------------

          Changing the text in the status bar:
          We'll create a buffer at memory address $7000 to change background tiles
          in the nametable. Format of entries in buffer:
       
          / A single byte
         05 |  20 00 | 0 | 70 71 51 12 12 | FOLLOWED BY ANOTHER ENTRY | ETC. | ENDS WHEN LENGTH IS SET TO 0
         |       |     |         |
         |       |     |    5 bytes of data
         |       |  Increment mode (0:1;1:32)
         |  PPU address (hi-byte/lo-byte)
        Length (how many tiles to change)

//////////////////////////////////////////////////////////////////////////////
// SPRITES / PPU OAM:
//////////////////////////////////////////////////////////////////////////////

 - The NES supports a maximum of 8 different sprites per scanline.
   The default behaviour is to hide sprites if there are more than 8.
   The hiding of sprites can be prevented by continously changing the order of 
   tiles in RAM / PPU OAM. This will cause a flickering effect for the tiles
   if there are more than 8 tiles visible on the same scanline, but it is
   better than the alternative, which is not displaying the excess tiles
   at all. Most NES programmers back in the day implemented this technique.
 - A metasprite is a big sprite composed of 4 or more "hardware" sprites
 - The OAM (Object Attribute Memory) is an internal memory inside the PPU
   that dictates where and how sprites will be displayed.
 - The OAM has 256 bytes of storage capacity and can store information 
   of a total of 64 sprites selected from the sprite pattern table.

 - The OAM memory is implemented using dynamic memory instead of static memory.
   Dynamic memory decays very fast, so we need to store the OAM data in RAM
   and load the data from RAM to the PPU OAM memory every frame.
   Procedure:
    - We write the OAM data to RAM (usually between $0200-$02FF)
    - We'll copy the contents from $0200-$02FF to the PPU OAM every frame (NMI).
    - We start the OAM copy by writing to the $4014 register. The NES implements
      this OAM copy via DMA (direct memory access (very fast)).

 - Sprite attribute data in the OAM occupies 4 bytes:
 
      3 2 1 0
      | | |  \_ X position
      | |  \_ Attribs -----> 7 6 5 4 3 2 1 0
      |  \_ Tile #           | | |        \_\_ Color palette (4-7)
       \_ Y position         | |  \_ Priority (0:in-front;1:behind background)
                             |  \_ Flip sprite horizontally
                              \_ Flip sprite vertically


///////////////////////////////////////////////////////////////////////////////
// CONTROLLER:
///////////////////////////////////////////////////////////////////////////////
            
      -----------------------       READ/WRITE      
     |                       |  <--- [LATCH]--->  7 6 5 4 3 2 1 0      
     |    |                  |                    | | | | | | |  \ 
     |  -   -                |                    | | | | | |  \  RIGHT
     |    |    == ==   O O   |                    | | | | |  \  LEFT
     |        /  /      \ \  |                    | | | |  \  DOWN
        SELECT  START    B A                      | | |  \  UP 
                                                  | |  \  START
                                                  |  \  SELECT
  - $4016 is the address for the 1st controller    \  B
  - $4017 is the address for the 2nd controller     A

  - Reading input from controller 1 and storing the values in the Buttons variable:
    .proc ReadControllers
        lda #1                   ; A = 1
        sta Buttons              ; Buttons = 1
        sta #$4016               ; Set Latch=1 to begin 'Input'/collection mode
        lsr                      ; A = 0
        sta #$4016               ; Set Latch=0 to begin 'Output' mode
    LoopButtons:
        lda #$4016               ; This reads a bit from the controller data line and inverts its value,
                                 ; And also sends a signal to the Clock line to shift the bits
        lsr                      ; We shift-right to place that 1-bit we just read into the Carry flag
        rol Buttons              ; Rotate bits left, placing the Carry value into the 1st bit of 'Buttons' in RAM
        bcc LoopButtons          ; Loop until Carry is set (from that initial 1 we loaded inside Buttons)
        rts
    .endproc

///////////////////////////////////////////////////////////////////////////////
// LINKS / RESOURCES:
///////////////////////////////////////////////////////////////////////////////

 - Nathan Altice, I Am Error
   A very good book that talks about working around
   the limitations of the NES platform.

 - Tile Editors:
    - NEXXT (Windows): https://frankengraphics.itch.io/nexxt
    - Nostalgic Assets Workshop (Windows): https://nesrocks.itch.io/naw

 - NESdev Wiki:
    - iNES header:             https://www.nesdev.org/wiki/INES
    - Init code:               https://www.nesdev.org/wiki/Init_code
    - PPU registers:           https://www.nesdev.org/wiki/PPU_registers
    - Random number generator: https://www.nesdev.org/wiki/Random_number_generator
    - Tile compression:        https://www.nesdev.org/wiki/Tile_compression

 - NES color palette: https://en.wikipedia.org/wiki/List_of_video_game_console_palettes#Nintendo_Entertainment_System

 - NROM template: https://github.com/pinobatch/nrom-template

 - Morphcat Games:
    - How we fit an NES game into 40 Kilobytes (Micro Mages): https://youtu.be/ZWQ0591PAxM
    - Talk & Play / Sprite Recycling (Micro Mages): https://www.kickstarter.com/projects/morphcat-games/triple-jump-a-platformer-multi-cartridge-for-the-nes/posts/3913486

 - NesHacker videos:
    - NES Hardware Explained:         https://youtu.be/mMq4FFUnBPc
    - NES Architecture Explained:     https://youtu.be/PwZEBE66an0
    - NES Graphics Explained:         https://youtu.be/7Co_8dC2zb8
    - The Code That Makes Mario Move: https://youtu.be/ZuKIUjw_tNU


///////////////////////////////////////////////////////////////////////////////
// OTHER NOTES:
///////////////////////////////////////////////////////////////////////////////

 - Acceleration -> Velocity -> Position:
   Acceleration is change in velocity per unit of time.
   Velocity is change in position per unit of time.

 - Example of game states:
     STATE - TITLESCREEN:
       TitleScreenLoop{
         - Read controller
         - Select menu option
         - Press "Start" button -> Go to GAMEPLAY state
       }          
     STATE - GAMEPLAY:
       GameLoop {
         - Read controller
         - Press "A" Button
         - Shoot missiles
         - Draw Sprites
         - Update/Collision check
         - If player dies -> Go to GAMEOVER state
       }
     STATE - GAMEOVER:
       GameOverLoop{
         - Read controller
         - Press "Start" button -> Go to TITLESCREEN state
       }
    We'll make a .proc for each of the states, not to use them as subroutes
    but to have different scopes for the different states.

// COLLSION DETECTION:

 - On modern hardware collision check might be implemented very simple with
   AABB (Axis-Align Bounding Box) collision checking.
   But most NES games does not perform a full box-box collision check, it uses
   too much processing power and cheaper sollutions are usually preferred.
   One way to do a cheaper collision check is to pick special points of our
   first object and check those against a certain region of the second object.

                Region of 2nd object
               /
   X1-----------+
   |            |
   |            |
   |     P      |
   +-----|------X2
         |  
   Collision point of 1st object
   (e.g. tip of missile, tip of sword, etc.)

   We check if point P is over X2, under X1, to the right of X1
   to the left of X2. If all of this is true then we have
   a collision!

 - Background collision check:
   To perform a background collision check, e.g. if the player is standing on
   a platform or colliding with a wall we can read the tilename from 
   the nametable in VRAM.
   Reading from VRAM is similar to writing to it. Reading can only be done
   when the PPU is off or during VBLANK.
   How to read from VRAM:
    - Set PPU_ADDR with the address we want to read from.
      (We can use screen coordinates (from player position x and y) and 
      convert that to the correct tile address in the active nametable)
    - Read the data from PPU_DATA (LDA PPU_DATA)
      (PPU_ADDR auto-increments, just like when we're storing data)
    - Check the result we got from PPU_DATA and see if it is a tile with
      collision.
    - Before rendering starts (after we've read from VRAM) it is customary to 
      set PPU_ADDR back to the address of the upper-left of the nametable to 
      prevent corruption of the picture frame.

// PSEUDO RANDOM NUMBER GENERATION:

 - (Pseudo) Random numbers using Linear-Feedback Shift Register (LFSR).
   A very common method for generating pseudo random numbers suitable for
   6502 programming. LFSR will shift bits and use a linear function
   (often XOR) to generate an output that appears random after a long cycle.
   The initial value of the LSFT is called a seed (seed cannot be 00000000).
   The operations of the registers are deterministic and the stream of values
   produced is completely determined by its current or previous state.
   Because the register has a finite number of possible states it eventually
   enters a repeating cycle. The taps will determine how long the cycle 
   period will be. The strength of the random number generation is determined
   by the number of bits used in the seed, and the choice of taps.

    +---< XOR <------+-----+
    |                |     |
    |                |     |
    +--------> D2    D1    D0
     FEEDBACK         \TAP  \TAP
 
    LFSR 4-bit example:
         1 0 0 1 <-- Seed
          \_\_Taps
         XOR the taps = 1
                        |
         ASL            |
    1 <- 0 0 1 1 <------+
        
   Continuing shifting left and feeding the XOR
   of the two leftmost bits into the rightmost bit:

         XOR--------+
         | |        |
    0 <- 0 1 1 0    |
    0 <- 1 1 0 1 <--+
    1 <- 1 0 1 0
    1 <- 0 1 0 1
    0 <- 1 0 1 1 
    1 <- 0 1 1 1
    0 <- 1 1 1 1 
    1 <- 1 1 1 0
    1 <- 1 1 0 0
    1 <- 1 0 0 0
    1 <- 0 0 0 1
    0 <- 0 0 1 0
    0 <- 0 1 0 0
    0 <- 1 0 0 1 <------- Reached back to the initial value (seed)
    1 <- 0 0 1 1
     \
      \_ The "random" bit we are generating

   Period = 2 to the power of (number of bits) 4 - 1
   Period is the amount of numbers we can generate before the cycle starts
   repeating. We have to subtract one since 0000 is not a possible value.

   If we have more than 4 bits we might use more than 2 taps.
   A common way to implement LFSR on the NES it to use
   a 16-bit seed and 3 taps.
   The period is then = 2 to the power of 16 - 1 = 65535
   (65 535 iterations before we start repeating the pattern from start)

   Example code for 16-bit Galois linear feedback shift register:
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; Returns a random 8.bit number inside A (0-255), clobbers Y (0).
   ;; Requires a 2-byte value on the zero-page called "Seed".
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; This is an 16-bit Galois linear feedback shift register with polynomial $0039.
   ;; The sequence of numbers it generates will repeat after 65535 calls.
   ;; Execution time is an average of 125 cycles (excluding jsr and rts)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
    Seed:           .res 2      ; 16-bit seed
    lda #$10
    sta Seed+1
    sta Seed+0                  ; Initialize the Seed with any value different than 0
   .proc GetRandomNumber
       ldy #8                   ; Loop counter (generate 8 bits)
       lda Seed+0
   :   asl                      ; Shift the register
       rol Seed+1
       bcc :+
         eor #$39               ; Apply XOR feedback when a 1 bit is shifted out
       :
       dey
       bne :--
       sta Seed+0               ; Saves the value in A into the Seed
       cmp #0                   ; Set flags
       rts
   .endproc

 - To make the PRNG (Pseudo Random Number Generator) less predictable we can
   add a timer at the start of the game and count how long it takes for the
   player to press the start button. We can use the result of the timer
   as the initial seed instead of hardcoding a value.

// COMPRESSION:

 - Run-Length Encoding (RLE) Compression:
   A way to compress data if we have a lot of repeating values is by
   using RLE Compression.

   A simple way to implement RLE is to encode length and tilenumber as a
   sequence of bytes.
   Example:
   FF FF FF FF FF FF FF FF A0 3F FE FE FE FE FE FE FE

   Becomes:
   08 FF 01 A0 01 3F 07 FE
    \ Number of times repeated

   The RLE can be more advanced with patterns:
   FF = Repetition pattern
   Example:
   FF 09 0A 0B
   |  |   |  |
   |  |   Pattern
   |   \ Number of times repeated
    \ Start of repetition pattern
   
   Means:
   0A 0B 0A 0B 0A 0B 0A 0B 0A 0B 0A 0B 0A 0B 0A 0B 0A 0B

 - Another popular algorithm for encoding tilemaps is the LZ77
   family of compressors. (Used by Kirby's Adventure)

 - Other techniques for level compression that are
   popular among NES programmers:
    - Metatiles:
      Predefined configurations of tiles that stick to a constant set of
      dimensions. Many NES games use metatiles that are 32 x 32 pixels.
    - Tile Blocks:
      Another popular technique that can help reduce the size of level
      information in ROM is to define large groups of tiles that repeat
      as a block.
    - Object-based Compression:
      Two-byte object compression
      Three-byte object compression
      Single-byte object compression

  - IMPORTANT: Encoding and compression are at the core of any NES game!

