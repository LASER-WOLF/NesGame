///////////////////////////////////////////////////////////////////////////////
// GIT VERSION HISTORY:
///////////////////////////////////////////////////////////////////////////////
 - 00001001:
     - Course section 13: Scrolling Background
        - Implemented dynamic loading of scrolling color attribute data
          for the background
        (Completed section)
 - 00001000:
     - Course section 13: Scrolling Background
        - Implemented simple horizontally scrolling background
        - Improved the scrolling background by swapping nametables when
          reaching the end of the current one.
        - Changed the project structure and moved from making simple examples
          to working on a bigger game prototype "Atlantico" (09_atlantico)
        - Implemented dynamic loading of scrolling background tiles.
 - 00000111:
     - Course section 12: Subpixel Movement
        - Changed player position to use 16-bit 8.8 fixed-point math, 
          affected by acceleration and velocity.
        - Implemented signed velocity to support negative values.
        - Added animation when moving
        (Completed section)
 - 00000110:
     - Course section 11: Controller Input
        - Implemented Buttons variable and subroutine to read button presses
          and store them in the variable.
        - Mapped directional button presses to move player sprite
        - Changed the values for controller related operations to constants
        (Completed section)
 - 00000101:
     - Course section 10: Sprites
        - Added test sprite data(SpriteData), a subroutine for storing sprite 
          data in RAM (LoadSprites) and instructions to update PPU OAM from RAM
          every frame (on MNI (VBLANK)).
        - Added hiding of unused sprites in OAM data initialization
        - Implemented loading of background data and attributes from .nam file
        - Added another test sprites. Now displaying two static test sprites.
        (Completed section)
 - 00000100:
     - Course section 09: Background Graphics
        - Loading of CHR background tiles for the first nametable
        - Loading of attributes for the first nametable
        - Created dynamic macros for PPU_SETADDR and PPU_SETDATA
        - Added frame counter and seconds counter as variables in the zero page
        - Frame counter increments on every vblank and seconds counter
          increments when frame counter reaches 60
        - Added pointer BgPtr for BackgroundData
        - Made subroutine for looping through and loading all tiles and
          attributes to the first nametable
        - Made subroutine for drawing text (in drawtext.asm)
        (Completed section)
 - 00000011:
     - Course section 08: NES Graphics
        - Divided the code into multiple include (.inc) files
        - Implemented loading of color palette
        - Implemented the color palette loading as a subroutine "LoadPalette" 
          that can be triggered with JSR LoadPalette
        (Completed section)
 - 00000010:
     - Course section 08: NES Graphics
        - Communicating with the PPU and rendering a solid color background (helloppu.asm)
        - Added code for initializing the NES to a stable state
 - 00000001:
     - Course section completed: 01 - Introduction
     - Course section completed: 02 - History & Early Years
     - Course section completed: 03 - NES Hardware
     - Course section completed: 04 - Binary & Hexadecimal
     - Course section completed: 05 - The 6502 Processor
     - Course section completed: 06 - 6502 Assembler
     - Course section completed: 07 - Intro to 6502 Assembly



///////////////////////////////////////////////////////////////////////////////
// NINTENDO ENTERTAINMENT SYSTEM (NES) SPECIFICATIONS:
///////////////////////////////////////////////////////////////////////////////
 - CPU (NTSC)      : Ricoh 2A03 8-bit processor (6502 core) @ 1.79MHz
 - CPU (PAL)       : Ricoh 2A07 8-bit processor (6502 core) @ 1.66MHz
 - Internal memory : 2KB WRAM + 2KB VRAM + 256 Bytes SPR-RAM
 - Graphics        : Ricoh 2C02 PPU (256x240 pixels)


###############################################################################
#                            Ricoh 2A03 CPU (6502)                            #
###############################################################################

                               6502 CPU PINOUT
                               ----------------
                     GND-----<|1             40|>-----RES(INV)
                     RDY-----<|2             39|>-----φ2(OUT)
                 φ1(OUT)-----<|3             38|>-----SO
                IRQ(INV)-----<|4             37|>-----φ0(IN)
                      NC-----<|5             36|>-----NC
                NMI(INV)-----<|6      R      35|>-----NC
                    SYNC-----<|7      I      34|>-----R/W(INV)
                     VCC-----<|8      C      33|>-----D0
                      A0-----<|9      O      32|>-----D1
                      A1-----<|10     H      31|>-----D2
                      A2-----<|11            30|>-----D3
                      A3-----<|12     2      29|>-----D4
                      A4-----<|13     A      28|>-----D5
                      A5-----<|14     0      27|>-----D6
                      A6-----<|15     3      26|>-----D7
                      A7-----<|16            25|>-----A15
                      A8-----<|17            24|>-----A14
                      A9-----<|18            23|>-----A13
                     A10-----<|19            22|>-----A12
                     A11-----<|20            21|>-----VSS
                               ----------------


                              6502 CPU REGISTERS
############################## [8-BIT DATA BUS] ###############################
|    |            |       |            |                                      |
|    |            |       |            |                                      |
|  -------------------------------------------------------------------------  |
|    |            |       |            |                                      |
|  [Y(8)]-------[X(8)]  [A(8)]         |                                      |
|  (INDEXED REGISTERS)  (ACCUMULATOR)  |                                      |
I    |                   |  |  |       |                                      M
N    |                   |  |  |       |                                      E
/  [SP(8)]               |  |   \     /                                       M
O  (STACK POINTER)       |  |     \ /                                         O
U    |                   |  |    [ALU]--------------------[P]                 R
T    |                   |  |    (ARITHMETIC-LOGIC UNIT)  (PROCESSOR FLAGS)   Y
|  [PC(16)]              |  |______|                       N V - B D I Z C    |
|  (PROGRAM COUNTER)     |                                                    |
|    |                   |                                                    |
|  -------------------------------------------------------------------------  |
|    |                   |                                                    |
|    |                   |                                                    |
########################### [16-BIT ADDRESS BUS] ##############################


///////////////////////////////////////////////////////////////////////////////
// 6502 PROCESSOR STATUS FLAGS REGISTER:
///////////////////////////////////////////////////////////////////////////////

 7 6 5 4 3 2 1 0  <--- Bit
 N V - B D I Z C  <--- Flag
 | |   | | | | |
 | |   | | | | |
 | |   | | | | |___ Carry Flag             0 = False            1 = True
 | |   | | | |
 | |   | | | |____ Zero flag               0 = Result not zero  1 = Result zero
 | |   | | |
 | |   | | |_____ IRQ Disabled flag        0 = Enable           1 = Disable
 | |   | |
 | |   | |______ Decimal mode (BCD) flag   0 = False            1 = True
 | |   |                        |  
 | |   |_______ Break flag      |          0 = No break         1 = Break
 | |                            |
 | |_________ Overflow flag     |          0 = False            1 = True
 |                              |
 |__________ Negative flag      |          0 = Positive         1 = Negative
                                |
                               NOTE: The BCD flag is disabled on the NES CPU

// Carry flag:
   [0] 1 1 1 1 1 1 1 1  =  [FF]
 + [0] 0 0 0 0 0 0 0 1  =  [01]
  ---------------------
 = [1] 0 0 0 0 0 0 0 0  =  [00]
     \
       \ __ CARRY FLAG

// Negative numbers using two's complement:
 -128's  64's  32's  16's   8's   4's   2's   1's
    |     |     |     |     |     |     |     |
    |     |     |     |     |     |     |     |
    -     -     -     -     -     -     -     -
    0     1     1     1     1     1     1     1  =  [7F]  =  127 
    -     -     -     -     -     -     -     -
    1     0     0     0     0     0     0     0  =  [80]  =  -128
    -     -     -     -     -     -     -     -
    1     1     1     1     1     1     1     1  =  [FF]  =  -1
    -     -     -     -     -     -     -     -

// Overflow flag (overflow to negative):
   0 1 1 1 1 1 1 1  =  [7F]  =  127
 + 0 0 0 0 0 0 0 1  =  [01]  =  1
  -----------------
 = 1 0 0 0 0 0 0 0  =  [80]  =  -128
    \
      \ __ SIGN BIT


///////////////////////////////////////////////////////////////////////////////
// CPU MEMORY MAP:
///////////////////////////////////////////////////////////////////////////////

 $0000           $2000           $4020                                   $FFFF
 |               |               |                                       |
 #      RAM      #   PPU & APU   #              CARTRIDGE SPACE          #
  ----------------------------------------------------------------------- 
 | Z |     |     |           |   |               |                   |   | 
 | E |  S  |     |           |   |               |                   | V |
 | R |  Y  |     |           |   |               |                   | E |
 | O |  S  |     |     P     | A |    PRG-RAM    |                   | C |
 |   |  T  |     |     P     | P |    BAT SAVE   |      PRG-ROM      | T |
 | P |  E  |     |     U     | U |    MAPPER     |                   | O |
 | A |  M  |     |           |   |               |                   | R |
 | G |     |     |           |   |               |                   | S |
 | E |     |     |           |   |               |                   |   |
  -----------------------------------------------------------------------
     #     #                 #                   #                   #
     |     |                 |                   |                   |
     $00FF $0800             $4000               $8000               $FFFA

 - Memory mapped I/O
 - 16-bit address space (2 to the power of 16 = 65.536 = 64KB)
 - Discrete Logic Chip figures out the location of the address (RAM/PPU/etc.)
   when you are sending instructions to the CPU.
 - System RAM: $0000 - $0800 (2KB internal RAM)
     - Page zero (fast!): $0000 - $00FF
     - Some parts of the 2KB of internal RAM at $0000 - $07FF have
       predefined purposes by the 6502 architecture.
     - The stack always uses some part of the $0100 - $01FF page.


///////////////////////////////////////////////////////////////////////////////
// 6502 ASSEMBLER:
///////////////////////////////////////////////////////////////////////////////

 - The ca65 assembler turns 6502 assembly code into machine code:
     LDA #2 -> [ASSEMBLER] -> (A9 02) 1010 1001 0000 0010
       \                          \       \
        Assembly code              Hex     * Machine code
   
   * Machine code is the raw binary values fed to the processor to perform a
     certain operation.
 
 - Examples of assembly to hex:
   LDA = Load decimal value to A (accumulator)
   STA = Store value from A to memory address
   LDX = Load the X register with value from memory
   DEX = Decrement X
   
   Assembly:     Hex:
   LDA #2     =  A9 02
   STA $2B    =  85 2B
   LDX $1234  =  AE 34 12
   DEX        =  CA    \
                        * 12 has swapped places with 34
   
   * NES has a Little Endian architecture

 - Installing the ca65 assembler and the FCEUX NES emulator on Arch Linux:
     $ yay -S cc65
     $ sudo pacman -S fceux

 - Assembling .nes file:
     $ ca65 <name>.asm -o <name>.o
     $ ld65 -C nes.cfg <name>.o -o <name>.nes

 - Running .nes file:
     $ fceux <name>.nes

 - Assembling, running and cleaning (deleting assembled files) can be done
   with a Makefile.


///////////////////////////////////////////////////////////////////////////////
// 6502 ASSEMBLY CODE:
///////////////////////////////////////////////////////////////////////////////

 - Roll-off: When decrementing $00 -> $FF
 - Roll-off: When incrementing $FF -> $00
 - Macros are copy/pasted code by the assembler
 - Subroutines are jumps that happen at runtime
 - Labels are memory addresses that can be referenced by name
 - Unnamed labels can be created with : and referenced with :- (previous) or :+ (next)
 - Pointers are a 16-bit address stored as lo-byte, followed by hi-byte.
   And are referenced by using parentheses.
   Ptr: .res 2 ; Reserving 2 bytes (16 bits) for the pointer Ptr during variable declaration
   lda #<Adr   ; Loading the lo-byte of the address Adr into A
   sta Ptr     ; Storing the lo-byte to the pointer Ptr
   lda #>Adr   ; Loading the hi-byte of the address Adr into A
   sta Ptr+1   ; Storing the hi-byte to the pointer Ptr
   (Ptr)       ; Referencing the pointer Ptr
   (Ptr),y     ; Referencing the pointer Ptr with a offset Y (only the register Y can be used to offset a pointer)
 - Multiplication and division by 2,4,6,8,16 etc. can by done with bit shifting
   (ASL) Shifting left is equivalent to multiplying by 2.
   Example: (27) 00011011 * 2 = (54) 00110110
   (LSR) Shifting right is equivalent to dividing by 2.
   Example: (74) 01001010 / 2 = (37) 00100101
 - Two bytes can be combined to create a decimal number with the hi-byte
   representing the integer part and the lo-byte the fractional part of the number.
   16-bit number using 8.8 fixed-point math: hi-byte . lo-byte
                                      Integer part /          \ Fractional part
 - 8-bit -> 16-bit sign extension:
   To sign extend any number from 8 bits to 16 bits, we look at the sign-bit 
   of the original number and we copy it to all the new bits of the high-byte 
   of the new 16-bit number. If the original sign-bit was 0, we fill all the 
   left new bits with 0. If the original sign-bit was 1, we fill all the 
   new left bits with 1.


///////////////////////////////////////////////////////////////////////////////
// 6502 INSTRUCTIONS (OPCODES):
///////////////////////////////////////////////////////////////////////////////

 - List of 6502 instructions:      
     http://www.6502.org/tutorials/6502opcodes.html

 - List of 6502 instructions (alt link):
     http://www.6502.org/users/obelisk/6502/instructions.html

 - Load and store instructions:
     LDA  ; load the A register
     LDX  ; load the X register
     LDY  ; load the Y register

     STA  ; store the A register
     STX  ; store the X register
     STY  ; store the Y register
 
 - Loading / storing modes:
     Immediate mode:               
     LDA #80    ; Loads the A register with the literal decimal value 80
     
     Absolute (zero-page) mode:    
     LDA $80    ; Loads the A register with the value inside memore address $80
     
     Immediate mode:               
     LDA #$80   ; Loads the A register with the literal hexadecimal number $80
     
     Absolute (zero-page) indexed: 
     STA $80,X  ; Store the value of A into memory address ($80 + X)

- Arithmetic instructions (addition, subtract):
     ADC  ; add to the accumulator (with carry)
     SBC  ; subtract from the accumulator (with carry)

     CLC  ; clear the carry flag (usually performed before addition)
     SEC  ; sets the carry flag (usually performed before subtraction)
 
 - Increment and Decrement instructions:
     INC  ; increment memory by one
     INX  ; increment X by one
     INY  ; increment Y by one
 
     DEC  ; decrement memory by one
     DEX  ; decrement X by one
     DEY  ; decrement Y by one

     ; Flag Z=1 if the result is zero, 0 otherwise
     ; Flag N=1 if bit 7(sign bit) is 1, 0 otherwise
     ; Note: The accumulator has no increment instruction. Use CLC and ADC #1 instead.

 - Logical Instructions:
     AND  ; logical AND
     EOR  ; exclusive OR
     ORA  ; logical inclusive OR
     BIT  ; bit test

     ; AND: The result of a logical AND is only true if both inputs are true.
     ;      A bitwise AND can be used to mask certain bits of a byte.
     ; ORA: The result of a logical OR (ORA) is true if at least
     ;      one of the inputs are true.
     ; EOR: An Exclusive-OR is similar to logical OR, with the exception that
     ;     it is false when both inputs are true.


     ; AND #%00000001 - Can be used to mask all but the rightmost bit, if the
     ; result is true it means the original number is an
     ; even number and divisible by two.
     ; AND #%00000011 - Can be used to mask all but the two rightmost bits, if the
     ; result is true it means the original number is divisible by four.
     ; AND #%00000111 - If the result is true the original number is 
     ; divisible by eight
     ; AND #%00001111 - Divisible by 16
     ; et cetera...

     ; EOR #1 can be used to flip a bit (0 -> 1 or 1 -> 0)

 - Jump, Branch, Compare Instructions:
     JMP  ; jump to another location     GOTO

     BCC  ; branch on carry clear        C == 0
     BCS  ; branch on carry set          C == 1
     BEQ  ; branch on equal to zero      Z == 1
     BNE  ; branch on not equal to zero  Z == 0
     BMI  ; branch on minus              N == 1
     BPL  ; branch on plus               N == 0
     BVC  ; branch on overflow clear     V == 0
     BVS  ; branch on overflow set       V == 1
     
     CMP  ; compare accumulator
     CPX  ; compare X register
     CPY  ; compare Y register

     ; The CMP instruction is used to compare a value from memory with the one 
     ; in the accumulator. It sets the N(egative), Z(ero) and C(arry) flags
     ; depending on the result of the comparison:
     ; 
     ;   CMP Value:    N Z C
     ;   If A < Value  - 0 0
     ;   If A = Value  0 1 1
     ;   If A > Value  - 0 1

 - Shift and Rotate Instructions:
     ASL  ; arithmetic shift left
     LSR  ; logical shift right
     ROL  ; rotate left
     ROR  ; rotate right

     ; LSR: Logical Shift Right, moves all bits one step to the right.
     ;      Inserting a 0 in the leftmost bit and moving the rightmost bit
     ;      to the carry flag.
     ;      1 0 1 0 1 1 1 1 -> [1] 0 1 0 1 0 1 1 1
     ; ASL: Logical Shift Left, same as LSR but moving bits one step to the left.
     ;      Inserting a 0 in the rightmost bit and moving the leftmost bit
     ;      to the carry flag.
     ;      1 0 1 0 1 1 1 1 -> [1] 0 1 0 1 1 1 1 0
     ; ROR: Rotate Right, moves all the bits one step right.
     ;      The rightmost bit moves over to the leftmost side.
     ;      1 0 1 0 1 1 1 1 -> 1 1 0 1 0 1 1 1
     ; ROL: Rotate Left, moves all the bits one step left.
     ;      The leftmost bit moves over to the rightmost side.
     ;      1 0 1 0 1 1 1 1 -> 0 1 0 1 1 1 1 1

 - Transfer Instructions:
     TAX  ; transfer A to X
     TAY  ; transfer A to Y
     TXA  ; transfer X to A
     TYA  ; transfer Y to A

 - Stack Instructions:
     TSX  ; transfer stack pointer to X
     TXS  ; transfer X to stack pointer
     PHA  ; push accumulator on stack
     PHP  ; push processor status on stack
     PLA  ; pull accumulator from stack
     PLP  ; pull processor status from stack

 - Subroutine Instructions:
     JSR  ; jump to a subroutine
     RTS  ; return from a subroutine

 - Set/Reset Instructions:
     CLD  ; clear decimal mode flag
     CLI  ; clear interrupt disable flag
     CLV  ; clear overflow flag 
     SEI  ; set interrupt disable flag
     RTI  ; return from interrupt

     ; It is customary to add a CLD (clear decimal mode flag) instruction
     ; during initialization since the NES does not support the decimal flag.

 - NOP/BRK Instructions:
     BRK  ; force an interrupt
     NOP  ; no operation


###############################################################################
#                                NES GRAPHICS                                 #
###############################################################################

                                 [TV SCREEN]
                               256 x 240 PIXELS
                            (NTSC 60Hz / PAL 50Hz)
                     -----------------------------------   <-
                    |                                   |    | 
                    |           ,___          .-;'      |    |
                    |           `"-.`\_...._/`.`        |    |
                    |        ,      \        /          |    |
                    |     .-' ',    / ()   ()\          | H  |
                    |    `'._   \  /()    .  (|         | B  |
                    |        > .' ;,     -'-  /         | L  |
                    |       / <   |;,     __.;          | A  |-- 240 VISIBLE
                    |       '-.'-.|  , \    , \         | N  |    SCANLINES
                    |          `>.|;, \_)    \_)        | K  |
                    |           `-;     ,    /          |    |
                    |              \    /   <           |    |
                    |               '. <`'-,_)          |    |
                    |                '._)               |    |
                    |                                   |    |
                     -----------------------------------   <-
                    |                                   |    |
                    |               VBLANK              |    |-- 21 SCANLINES
                    |                                   |    |   OF  VERTICAL
                     ----------------------------------    <-       BLANK
                    |---------341 PPU CYCLES/PIXELS----------|
                    |----256 VISIBLE SCANLINE PIXELS----|



///////////////////////////////////////////////////////////////////////////////
 
 - Each NTSC frame has a total of 262 scanlines:
   240 visible scanlines + 21 scanlines of VBLANK + 1 scanline of pre-VBLANK
 - VRAM has to be updated during the period of VBLANK
 - The PPU triggers an NMI interrupt to the CPU every time a new VBLANK starts.
 - HBLANK is the time it takes from the beam to go from right to left again
   after each scanline. The PPU handles this for us.
 - Each scanline lasts 341 PPU clock-cycles. This is the same as
   113.6 CPU clock cycles. 1 CPU cycle = 3 PPU cycles.

///////////////////////////////////////////////////////////////////////////////
// PATTERN TABLES AND NAMETABLES:
///////////////////////////////////////////////////////////////////////////////

           [8x8  TILE]
            16  BYTES         [PATTERN TABLE]           [CHR-ROM]
         0 0 1 1 2 2 3 3        4096  BYTES             8192 BYTES   
         0 0 1 1 2 2 3 3      ---------------       ------------------
         0 0 1 1 2 2 3 3     |   256 TILES   |     | 2 PATTERN TABLES |
         0 0 1 1 2 2 3 3 --> | STORED IN ONE | --> |    STORED ON     |
         0 0 1 1 2 2 3 3     | PATTERN TABLE |     |    CARTRIDGE     |
         0 0 1 1 2 2 3 3      ---------------       ------------------
         0 0 1 1 2 2 3 3                                  | 
         0 0 1 1 2 2 3 3                                  |
          \                                               |
          COLOR INDEX (0-3)                               |
              2 BITS                                      |
                                                          |
                          [NAMETABLE]                     |
                           1024 BYTES                     |
                    -----------------------               |
                   |       960 BYTES:      |    REFERENCE |
                   | STORES 960 REFERENCES |  <-----------+
                   |   TO TILES SELECTED   |
                   |  FROM THE BACKGROUND  |          [VRAM]
                   |     PATTERN TABLE     |        2048 BYTES
                   |    FORMING A 32x30    |       ------------
                   |   GRID TO FILL THE    |      |  STORES 2  |
                   |     ENTIRE SCREEN     |      | NAMETABLES |
                    -----------------------   --> | CONTAINING |
                   |       64 BYTES:       |      | TILES AND  |
                   | STORES 64 REFERENCES  |      | COLOR DATA |
                   |   TO COLOR PALETTES   |       ------------
                   |   SELECTED FROM THE   |
                   |   BACKGROUND COLOR    |
                   |  PALETTE SET FORMING  |    REFERENCE
                   |  A 8x8 GRID TO COLOR  |  <-----------+
                   |   ALL THE TILES IN    |              |
                   |     GROUPS OF 4       |              |
                    -----------------------               |
                                                          |
                                                          |
         [SET OF COLOR PALETTES]                        [WRAM]
                16 BYTES                               32 BYTES
    [01 02 03 04] ----------> PALETTE #1       --------------------------
       [05 06 07 08] -------> PALETTE #2      | 2 SETS OF COLOR PALETTES |
          [09 10 11 12] ----> PALETTE #3  --> |  ONE SET FOR BACKGROUND  |
             [13 14 15 16] -> PALETTE #4      |  AND ONE SET FOR SPRITES |
                \                              -------------------------- 
                 1 BYTE REPRESENTING          
                    A SINGLE COLOR

 - A vanilla cartridge has two pattern tables (0: Sprites and 1: Background)
   but more pattern tables can be added if the cartridge has a mapper.
   A pattern table contains 256 tiles. A tile can be 8x8 or 8x16.
   Each "pixel" on a tile contains a value from 0-3, representing an index
   to reference a color from the selected a color palette.
 - VRAM contains two nametables used to draw the background.
   Each nametable needs to store tiles (from the pattern tables)
   and color data. VRAM has 2048 bytes of storage capacity that 
   is divided into 1024 bytes assigned for each of the two nametables.
   Tiles are stored in the 32x30 tile grid and colors are stored
   in the 8x8 attribute grid. Each entry in both the tile grid and
   the attribute grid needs 1 byte of storage space.
   A nametable contains 960 tiles + 64 color attributes, totalling 1024 bytes.
 - The color palette contains two sets of 4 color palettes.
   One set for painting the background tiles and one set for painting 
   the sprites. Each set contain 4 palettes and each individual palette
   contains 4 colors represented as a value between 0-255.
   The first color in every indvidual palette is the background color.
 - The pattern tables can be thought of as different brushes 
   while the nametable is the canvas in which we paint the final result.

 - Nametable mirroring is used to enable scrolling backgrounds:

            VERTICAL MIRRORING:         HORIZONTAL MIRRORING:
            USED FOR GAMES THAT         USED FOR GAMES THAT
            SCROLL HORIZONTALLY         SCROLL VERTICALLY
                 --- ---                
                | A | B |                 ---    M    ---
                 --- ---                 | A | <-I-> | A |
                  |   |                   ---    R    ---
               M I R R O R               | B | <-R-> | B |
                  |   |                   ---    O    --- 
                 --- ---                         R        
                | A | B |
                 --- ---


///////////////////////////////////////////////////////////////////////////////

                                COLOR PALETTE
                                -------------
                                (4)BACKGROUND                  
                                (4)SPRITES                     NAME TABLE 0
                                -------------                  + ATTRIBUTES
  PATTERN TABLE 0                     |                        NAME TABLE 1
  PATTERN TABLE 1                     |                        + ATTRIBUTES
        |                             |                             |
     CHR-ROM <--------------------> [PPU] <--------------------> 2KB VRAM
   (CARTRIDGE)             (PICTURE PROCESSING UNIT)            (VIDEO RAM)
                                      |
                                      |
                                PPU REGISTERS
                              -----------------
                              $2000:   PPU_CTRL
                              $2001:   PPU_MASK
                              $2002: PPU_STATUS
                              $2003:   OAM_ADDR
                              $2004:   OAM_DATA
                              $2005: PPU_SCROLL
                              $2006:   PPU_ADDR
                              $2007:   PPU_DATA
                              -----------------


///////////////////////////////////////////////////////////////////////////////
// PPU REGISTERS:
///////////////////////////////////////////////////////////////////////////////

   $2000 : PPU_CTRL   :  7 6 5 4 3 2 1 0
                         | | | | | |  \ \ 
                         | | | | | |   Base name table address
                         | | | | | |   00: $2000  ;  01: $2400
                         | | | | | |   10: $2800  ;  11: $2C00
                         | | | | |  \
                         | | | | |   PPU_DATA increment size
                         | | | | |   0: add 1, going accross
                         | | | | |   1: add 32, going down
                         | | | |  \
                         | | | |   Sprite pattern table no. (0;1)
                         | | |  \
                         | | |   Background pattern table no. (0;1)
                         | |  \
                         | |   Sprite size
                         | |  0:8x8; 1:8x16
                         |  \
                         |   PPU master/slave select (0;1)
                          \
                           Generate NMI at the start of VBLANK? (0;1)

   $2001 : PPU_MASK   :  7 6 5 4 3 2 1 0
                         | | | | | | |  \ 
                         | | | | | | |   Grayscale
                         | | | | | |  \
                         | | | | | |   Show background in leftmost 8 pixels
                         | | | | |  \ 
                         | | | | |   Show sprites in leftmost 8 pixels
                         | | | |  \ 
                         | | | |   Show background
                         | | |  \ 
                         | | |   Show sprites
                         | |  \ 
                         | |   Emphasize red
                         |  \ 
                         |   Emphasize green
                          \ 
                           Emphasize blue

   $2002 : PPU_STATUS :  7 6 5 4 3 2 1 0
                         | | |  \ \ \ \ \
                         | | |   PPU open bus
                         | |  \
                         | |   Sprite overflow
                         | |   (more than 8 sprites in one scanline)
                         |  \
                         |   Sprite-0 Hit
                          \
                           In VBLANK (0:Not in VBLANK; 1:In VBLANK)

   $2003 : OAM_ADDR   : Define address of sprite OAM here (usually $00)
   $2004 : OAM_DATA   : Write OAM data here (usually not used directly)
   $2005 : PPU_SCROLL : Used to write the scroll position 
                        (Indicates which pixel of the nametable
                        is at the top-left corner)
   $2006 : PPU_ADDR   : Write the hi-byte & lo-byte of the PPU address
                        (LATCH REGISTER)
   $2007 : PPU_DATA   : Write the data to be sent to the address
                        defined at PPU_ADDR

 PPU_STATUS/PPU_ADDR/PPU_DATA:
 - PPU_ADDR is a latch register that takes a 8-bit hi-byte, followed by
   a 8-bit lo-byte and stores the combined values as a 16-bit memory address.
 - When PPU_STATUS is read (e.g. BIT PPU_STATUS) the PPU_ADDR latch is reset.
 - When storing a byte in PPU_DATA the PPU_ADDR is automatically incremented.

//////////////////////////////////////////////////////////////////////////////
// PPU MEMORY MAP:
//////////////////////////////////////////////////////////////////////////////

           $0000 ------- #-----------------# --------
                         | PATTERN TABLE 0 | CHR-ROM
                         |                 |
           $1000 ------- #-----------------# --------
                         | PATTERN TABLE 1 | CHR-ROM
                         |                 |
           $2000 ------- #-----------------# --------
                         |  NAME TABLE 0   | 1KB
                         |  + ATTRIBUTES   |
           $2400 ------- #-----------------# --------
                         |  NAME TABLE 1   | 1KB
                         |  + ATTRIBUTES   |
           $2800 ------- #-----------------# --------
                         |  NAME TABLE 2   | 1KB
                         |  + ATTRIBUTES   |
           $2C00 ------- #-----------------# --------
                         |  NAME TABLE 3   | 1KB
                         |  + ATTRIBUTES   |
           $3000 ------- #-----------------# --------
                         |     MIRRORS     |
                         |   $2000-$2EFF   |
           $3F00 ------- #-----------------# --------
                         |   PALETTE BG    | 16 bytes
                         |-----------------| --------
                         | PALETTE SPRITES | 16 bytes
                         #-----------------#
              
              
//////////////////////////////////////////////////////////////////////////////
// SPRITES / PPU OAM:
//////////////////////////////////////////////////////////////////////////////

 - The NES supports a maximum of 8 different sprites per scanline.
   The default behaviour is to hide sprites if there are more than 8.
   The hiding of sprites can be prevented by continously changing the order of 
   tiles in RAM / PPU OAM. This will cause a flickering effect for the tiles
   if there are more than 8 tiles visible on the same scanline, but it is
   better than the alternative, which is not displaying the excess tiles
   at all. Most NES programmers back in the day implemented this technique.
 - A metasprite is a big sprite composed of 4 or more "hardware" sprites
 - The OAM (Object Attribute Memory) is an internal memory inside the PPU
   that dictates where and how sprites will be displayed.
 - The OAM has 256 bytes of storage capacity and can store information 
   of a total of 64 sprites selected from the sprite pattern table.
 - The OAM memory is implemented using dynamic memory instead of static memory.
   Dynamic memory decays very fast, so we need to store the OAM data in RAM
   and load the data from RAM to the PPU OAM memory every frame.
 - We write the OAM data to RAM (usually between $0200-$02FF)
 - We'll copy the contents from $0200-$02FF to the PPU OAM every frame (NMI).
 - We start the OAM copy by writing to the $4014 register. The NES implements
   this OAM copy via DMA (direct memory access (very fast)).
 - Sprite attribute data in the OAM occupies 4 bytes:
 
      3 2 1 0
      | | |  \_ X position
      | |  \_ Attribs -----> 7 6 5 4 3 2 1 0
      |  \_ Tile #           | | |        \_\_ Color palette (4-7)
       \_ Y position         | |  \_ Priority (0:in-front;1:behind background)
                             |  \_ Flip sprite horizontally
                              \_ Flip sprite vertically


///////////////////////////////////////////////////////////////////////////////
// CONTROLLER:
///////////////////////////////////////////////////////////////////////////////

            
      -----------------------       READ/WRITE      
     |                       |  <--- [LATCH]--->  7 6 5 4 3 2 1 0      
     |    |                  |                    | | | | | | |  \ 
     |  -   -                |                    | | | | | |  \  RIGHT
     |    |    == ==   O O   |                    | | | | |  \  LEFT
     |        /  /      \ \  |                    | | | |  \  DOWN
        SELECT  START    B A                      | | |  \  UP 
                                                  | |  \  START
                                                  |  \  SELECT
  - $4016 is the address for the 1st controller    \  B
  - $4017 is the address for the 2nd controller     A

///////////////////////////////////////////////////////////////////////////////
// LINKS / RESOURCES:
///////////////////////////////////////////////////////////////////////////////

 - Tile Editors:
    - NEXXT (Windows): https://frankengraphics.itch.io/nexxt

 - NESdev Wiki:
    - iNES header:   https://www.nesdev.org/wiki/INES
    - Init code:     https://www.nesdev.org/wiki/Init_code
    - PPU registers: https://www.nesdev.org/wiki/PPU_registers

 - NES color palette: https://en.wikipedia.org/wiki/List_of_video_game_console_palettes#Nintendo_Entertainment_System

 - NROM template: https://github.com/pinobatch/nrom-template

 - NesHacker videos:
    - NES Hardware Explained:         https://youtu.be/mMq4FFUnBPc
    - NES Architecture Explained:     https://youtu.be/PwZEBE66an0
    - NES Graphics Explained:         https://youtu.be/7Co_8dC2zb8
    - The Code That Makes Mario Move: https://youtu.be/ZuKIUjw_tNU


///////////////////////////////////////////////////////////////////////////////
// OTHER NOTES:
///////////////////////////////////////////////////////////////////////////////

 - Acceleration -> Velocity -> Position:
   Acceleration is change in velocity per unit of time.
   Velocity is change in position per unit of time.
   

